# -*- coding: utf-8 -*-
"""traffic_light_forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18ftqZK5t2X6rgCb6wwsVMsWIQxQsHcMU
"""

!pip install prophet pandas

from google.colab import files

# Upload the CSV file first line 4 or 5
uploaded = files.upload()

# Confirm the filename (update this if needed after upload)
csv_filename = list(uploaded.keys())[0]
print(f"✅ Uploaded CSV file: {csv_filename}")

# Upload the PKL file next line 4 or 5
uploaded = files.upload()

# Confirm the filename (update this if needed after upload)
pkl_filename = list(uploaded.keys())[0]
print(f"✅ Uploaded PKL file: {pkl_filename}")

import pandas as pd

# Load the CSV data
df = pd.read_csv(csv_filename)

# Ensure timestamp is datetime and fix timezone issues (remove timezone if present)
df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce', utc=True)
df['timestamp'] = df['timestamp'].dt.tz_localize(None)

print(f"✅ Loaded data, sample:\n{df.head()}")

import joblib

# Try loading the model using joblib instead of pickle
model = joblib.load(pkl_filename)

print(f"✅ Loaded Prophet model from: {pkl_filename}")

# Prophet expects column 'ds' (date) — we are forecasting 'r01' so we need future timestamps
forecast_df = pd.DataFrame()
forecast_df['ds'] = df['timestamp']  # Only the timestamp column is needed for prediction

print(f"✅ Forecast dataframe prepared:\n{forecast_df.head()}")

# Predict using the trained Prophet model
forecast = model.predict(forecast_df)

# Show forecast (ds = date, yhat = predicted value)
print(f"✅ Forecast complete:\n{forecast[['ds', 'yhat']].head()}")

df_forecast = pd.merge(forecast[['ds', 'yhat']], df, left_on='ds', right_on='timestamp', how='left')

print(f"✅ Combined actual and predicted data:\n{df_forecast.head()}")

# Step 8: Define traffic light logic
def get_traffic_light(value, mean_value, threshold=0.2):
    """Classify sensor value into traffic light color based on thresholds."""
    if abs(value - mean_value) <= (threshold * mean_value):
        return "Green"  # Normal
    elif abs(value - mean_value) <= (threshold * 2 * mean_value):
        return "Yellow"  # Slightly abnormal
    else:
        return "Red"  # Abnormal

# Step 9: Apply traffic light system to the forecasted data
mean_r01 = df['r01'].mean()  # Calculate mean of the 'r01' sensor for comparison
forecast['traffic_light'] = forecast['yhat'].apply(lambda x: get_traffic_light(x, mean_r01))

# Step 10: Show results
print(f"✅ Traffic Light Results:\n{forecast[['ds', 'yhat', 'traffic_light']].head()}")

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

# Step 10: Visualize the forecast and traffic light system
plt.figure(figsize=(12, 6))

# Plot the forecasted 'yhat' values (predictions)
plt.plot(forecast['ds'], forecast['yhat'], label='Forecasted Values (yhat)', color='blue', linewidth=2)

# Plot traffic light colors for each forecasted value
colors = forecast['traffic_light'].map({
    'Green': 'green',
    'Yellow': 'yellow',
    'Red': 'red'
})

# Scatter plot with the traffic light colors
plt.scatter(forecast['ds'], forecast['yhat'], c=colors, label='Traffic Light', s=50, edgecolors='black')

# Add titles and labels
plt.title("Traffic Light System Visualization for Forecasted Sensor Values (r01)", fontsize=16)
plt.xlabel("Timestamp", fontsize=12)
plt.ylabel("Sensor Reading (r01)", fontsize=12)

# Rotate the x-axis labels for better readability
plt.xticks(rotation=45)

# Display a legend
plt.legend()

# Show the plot
plt.tight_layout()
plt.show()